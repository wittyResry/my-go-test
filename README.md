# https://tour.golang.org/basics/1

# package包
* 每个Go都是由包构成。程序从main包开始运行。package.go通过导入包路径"fmt"和"math/rand"来使用这 两个包
按照约定，包名与导入路径最后一个元素一致。例如`math/rand`包中的源码都是以package main语句开始的

# import规则
* 导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。 例如， Pi 就是个已导出名，它导出自 math 包。pizza 和 pi 并未以大写字母开头，所以它们是未导出的。在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。执行代码，观察错误输出。

# function函数
* 函数可以接收多个参数，类型定义在变量名之后。当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。`x int, y int`被缩写为`x, y int`

# 多值返回
* 函数可以返回任意数量的返回值。支持结构体参数透传

# 命名返回值
* Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。返回值的名称应当具有一定的意义，它可以作为文档使用。没有参数的 return 语句返回已命名的返回值。也就是`直接`返回。

# 变量和变量的初始化
* var 语句可以出现在包或函数级别。变量声明可以包含初始值，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。

# 短变量的声明
* 在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。函数外的每个语句都必须以关键字开始（ var 、 func 等等）， 因此 := 结构不能在函数外使用。没有明确初始值的变量声明会被赋予它们的值 。常量不能用 := 语法声明。

# switch语句和没有条件的 switch
* Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。
* 没有条件的 switch 同 switch true 一样。这种形式能将一长串 if-then-else 写得更加清晰。

# defer和defer栈
* defer 语句会将函数推迟到外层函数返回之后执行。推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

# GO指针
* Go 拥有指针。 指针保存了值的内存地址。类型 *T 是指向 T 类型值的指针。其零值为 nil 。& 操作符会生成一个指向其操作数的指针。这也就是通常所说的“间接引用”或“重定向”。

# 结构体
* 初始化{1, 2}，结构体字段使用点号来访问。结构体指针：如果我们有一个指向结构体的指针 p ，那么可以通过 (*p).X 来访问其字段 X 。

# 数组
* 数组的长度是其类型的一部分，因此数组不能改变大小。每个数组的大小都是固定的。 而切片则为数组元素提供动态大小的、灵活的视角。 在实践中，切片比数组更常用。切片就像数组的引用，更改切片的元素会修改其底层数组中对应的元素。在进行切片时，你可以利用它的默认行为来忽略上下界。切片下界的默认值为 0 ，上界则是该切片的长度。用 make 创建切片make([]int, 5)

# 向切片追加元素
* `func append(s []T, vs ...T) []T`，append 的第一个参数 s 是一个元素类型为 T 的切片， 其余类型为 T 的值将会追加到该切片的末尾。当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。


# Range
* for i, v := range arrays形式可遍历切片或映射。当使用 for 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

# 映射
* make 函数会返回给定类型的映射，并将其初始化备用。插入或修改元素`m[key] = elem`,获取元素：`elem = m[key]`,删除元素：`delete(m, key)`,通过双赋值检测某个键是否存在：`elem, ok := m[key]`

# **函数值 区别于C语言的重要特性**
* 函数也是值。它们可以像其它值一样传递。函数值可以用作函数的参数或返回值。

# **函数的闭包 区别于C语言的重要特性**
* Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。


# 方法即函数
* Go 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。

# 指针接收者
* 指针是传址，函数如果么有加*，则是表示传值。而以值为接收者的方法被调用时，接收者既能为值又能为指针：方法调用 p.Abs() 会被解释为 `(*p).Abs() `。带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&v).Scale(5) 。使用指针接收者的原因有二：首先，方法能够修改其接收者指向的值。其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。


# 接口
* 接口类型 是由一组方法签名定义的集合。接口类型的值可以保存任何实现了这些方法。指针类型定义的方法，只能用指针类型赋值给接口，不能用值类型赋值给接口。

# 接口与隐式实现
* 类型通过实现一个接口的所有方法来实现该接口。 既然无需专门显式声明，也就没有“implements“关键字。隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。

# 接口值
* 在内部，接口值可以看做包含值和具体类型的元组：`(value, type)` 接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。
* 如果是struct类型，在获取成员的时候，需要判断nil，防止出现空指针异常。

# nil 接口值
* nil 接口值既不保存值也不保存具体类型。为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。

# 空接口
* 空接口`interface{}`，空接口可保存任何类型的值。 （因为每个类型都至少实现了零个方法。）空接口被用来处理未知类型的值。 例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。

# 类型断言
* 该语句断言接口值 i 保存了具体类型 T ，并将其底层类型为 T 的值赋予变量 t 。`t := i.(T)`若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。
* `t, ok := i.(T)`若 i 保存了一个 T ，那么 t 将会是其底层值，而 ok 为 true 。否则， ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。

# Stringer与Error内建接口
* 通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。

```go
type Stringer interface {
    String() string
}

type IPAddr [4]byte

func (ip IPAddr) String() string {
	return fmt.Sprintf("%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3])
}

type error interface {
    Error() string
}

i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)
```
